<!doctype html>
<html>

<head>
	<title>Line Chart</title>
	<script src="https://www.chartjs.org/dist/2.9.3/Chart.min.js"></script>
	<script src="https://www.chartjs.org/samples/latest/utils.js"></script>
	<style>
	canvasGraph{
		-moz-user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}
	</style>
</head>

<body>
    <div style="height: 200px">
        <div>CardioBrowser Demo</div>
		<canvas id="canvasGraph"></canvas>
	</div>
	<br>
	<br>
	    
    
    <button type="button" onclick="init()">Start</button>
    <div><canvas id="canvas"></canvas></div>
    <div id="label-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
    <!--<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>-->
    <script type="text/javascript">

        var startTime;
        var movingAvg;

		var config = {
			type: 'line',
			data: {
				labels: [],
				datasets: [{
					label: 'Pulse',
					backgroundColor: window.chartColors.red,
					borderColor: window.chartColors.red,
					data: [],
					fill: false,
				}]
			},
			options: {
				responsive: true,
				// title: {
				// 	display: true,
				// 	text: 'Chart.js Line Chart'
				// },
                maintainAspectRatio: false,
				tooltips: {
					mode: 'index',
					intersect: false,
				},
                elements: {
                    point:{
                        radius: 0
                    }
                },
				// hover: {
				// 	mode: 'nearest',
				// 	intersect: true
				// },
				scales: {
					xAxes: [{
						display: true,
                        ticks: {
                            stepSize: 0.1
                        },
						scaleLabel: {
							display: true,
							labelString: 'Time'
						}
					}],
					yAxes: [{
						display: true,
						scaleLabel: {
							display: true,
							labelString: 'Norm. Amp.'
						}
					}]
				}
			}
		};

		window.onload = function() {
			var ctx = document.getElementById('canvasGraph').getContext('2d');
			window.myLine = new Chart(ctx, config);
		};

		var colorNames = Object.keys(window.chartColors);



        // More API functions here:
        // https://github.com/googlecreativelab/teachablemachine-community/tree/master/libraries/pose

        // the link to your model provided by Teachable Machine export panel
        const URL = "./2DCNNStack/";//"./TSM/"
        let model, webcam, ctx, labelContainer, prevFrame, cumSum;

        async function init() {
            const modelURL = URL + "model.json";
            const metadataURL = URL + "metadata.json";

            startTime = new Date();
            movingAvg = [];

            // load the model and metadata
            // Refer to tmImage.loadFromFiles() in the API to support files from a file picker
            // Note: the pose library adds a tmPose object to your window (window.tmPose)
            // model = await tmPose.load(modelURL, metadataURL);
            model = await tf.loadLayersModel(URL + 'model.json');

            // Convenience function to setup a webcam
            const size = 300;
            const flip = true; // whether to flip the webcam
            webcam = new tmPose.Webcam(size, size, flip); // width, height, flip
            await webcam.setup(); // request access to the webcam
            await webcam.play();
            window.requestAnimationFrame(loop);

            // append/get elements to the DOM
            const canvas = document.getElementById("canvas");
            canvas.width = size; canvas.height = size;
            ctx = canvas.getContext("2d");
            labelContainer = document.getElementById("label-container");
        }

        async function loop(timestamp) {
            webcam.update(); // update the webcam frame
            await predict();
            window.requestAnimationFrame(loop);
        }

        async function predict() {
            // Prediction:
            var img = tf.browser.fromPixels(webcam.canvas);
            img = tf.image.resizeBilinear(img, [36, 36])

            //img = img.toFloat().div(tf.scalar(127)).sub(tf.scalar(1));
            // DIVIDE BY 255:
            img = img.toFloat().div(tf.scalar(255));
            //img = tf.clip_by_value(t, clip_value_min=clip_min

            if(prevFrame == null)
            {
                prevFrame = img;
                cumSum = 0;
            }
            else
            {
                // FRAME DIFF:
                var diff = tf.div(tf.sub(img,prevFrame),tf.add(img,prevFrame))
                // SUBTRACT MEAN OF IMG:
                var img2 = tf.sub(img,tf.mean(img))
                img2 = tf.div(img2,tf.moments(img2).variance.sqrt())
                diff = tf.div(diff,tf.moments(diff).variance.sqrt())

                //diff = tf.div(diff,tf.variance(diff))
                //img = tf.div(img,tf.variance(img))

                var img3 = tf.concat([diff, img2], 2)
                var img4 = tf.stack([img3])
                //frame = tf.zeros([1, 36, 36, 6], tf.float)
                var prediction = await model.predict(img4);//webcam.canvas
                prediction = prediction.dataSync()
                prevFrame = img;
                cumSum = cumSum + prediction[0];

                // Moving Average:
                movingAvg.push(cumSum);
                if (movingAvg.length > 10) {
                    movingAvg.shift()
                }
                const average = arr => arr.reduce((sume, el) => sume + el, 0) / arr.length;

                // Add latest values:
                if (config.data.datasets.length > 0) {
                    var currentTime = new Date();
                    timeDiff = (currentTime - startTime)/1000;
                    config.data.labels.push(timeDiff);

                    config.data.datasets.forEach(function(dataset) {
                        d = (cumSum - average(movingAvg))
                        dataset.data.push(d);
                    });

                    config.data.datasets.forEach(function(dataset) {
                        if(dataset.data.length>300){
                            dataset.data.shift();
                            config.data.labels.shift();
                        }
                    });

                    window.myLine.update();
                }

            }

            drawFrame();
        }

        function drawFrame() {
            if (webcam.canvas) {
                ctx.drawImage(webcam.canvas, 0, 0);
            }
        }
    </script>
</body>